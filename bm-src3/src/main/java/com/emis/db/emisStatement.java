/* $Header: /repository/src3/src/com/emis/db/emisStatement.java,v 1.1.1.1 2005/10/14 12:42:05 andy Exp $ * * 2004/05/26 Jerry: emisDbMonitor中的SQL不會顯示; 秒數未歸零 */package com.emis.db;import com.emis.audit.emisAudit;import java.io.PrintWriter;import java.sql.*;import java.util.*;/** *  java.sql.Statement 的 wrapper class *  這樣可以方便我們作一些監控 *  @see java.sql.Statement */public class emisStatement implements Statement, emisStatementWrapper {	protected emisDbMgr dbMgr_;    protected emisConnectProxy oProxy_;    protected Statement stmt_;    protected String sSQL_ = null; // executing SQL            protected long start=0; // sql execute start time    protected long lastExecuteDuration = 0;    protected ArrayList oParam_ = new ArrayList();        protected void ensureCapacity(int cap) {        int size = oParam_.size();        if (size < cap)          oParam_.ensureCapacity(cap);        while (size < cap) {          oParam_.add(null);          size++;        }    }    public emisStatement(emisDbMgr dbMgr, emisConnectProxy oProxy, Statement stmt) {        dbMgr_ = dbMgr;        oProxy_ = oProxy;        stmt_ = stmt;        try {            stmt_.setFetchSize(100);          //  System.out.println("--------------------setFetchSize-----------------");        } catch (Exception e) {            e.printStackTrace();        }    }    public void desc(PrintWriter out) {        if (sSQL_ == null) return;        out.println(sSQL_);        int size = oParam_.size();        out.println("<br><font size='-2' color='blue'>");        for (int i = 0; i < size; i++) {          Object o = oParam_.get(i);          if (o != null)            out.println("PARAM" + (i + 1) + ":" + o.toString());        }        if( start != 0 ) {        	out.print("Executing:" + ((System.currentTimeMillis() - start) / 1000) + " 秒</font>");        } else {        	out.print("Done:" + (lastExecuteDuration / 1000) + " 秒</font>");        }      }    // robert, 2011/11/25 , merge code of the start and end of execution    protected void StartExecute() {        start = System.currentTimeMillis();        oProxy_.setExecutingStatement(this);        emisAudit.setLog(sSQL_, oParam_);    }        protected void Error(SQLException err) {    	lastExecuteDuration = System.currentTimeMillis() - start;    	dbMgr_.setSQLError(sSQL_,oParam_,start,err);      // 20130626 Joe Mark 去掉這個歸0 動作，不然有錯誤的SQL發生時會導致計算運行時間錯誤    	//start = 0;    	    }        protected void EndExecute() {    	lastExecuteDuration = System.currentTimeMillis() - start;    	// robert,我們保留最後一個, 這樣可以在 dbMonitor 看到最後一個執行的    	//oProxy_.setExecutingStatement(null);     	dbMgr_.setTopSQL(sSQL_, oParam_, start);    	start =0;    }    public ResultSet executeQuery(String sql) throws SQLException {        try {        	sSQL_=sql;        	StartExecute();        	return stmt_.executeQuery(sql);        } catch (SQLException sqlerr) {    	    this.Error(sqlerr);    	    throw sqlerr;        } finally {        	EndExecute();        	        }    }    public int executeUpdate(String sql) throws SQLException {        try {        	sSQL_=sql;        	StartExecute();            return stmt_.executeUpdate(sql);        } catch (SQLException sqlerr) {    	    this.Error(sqlerr);    	    throw sqlerr;        } finally {        	EndExecute();        }    }    public void close() throws SQLException {    	oProxy_.touch();        if (stmt_ != null) stmt_.close();    }    public int getMaxFieldSize() throws SQLException {        return stmt_.getMaxFieldSize();    }    public void setMaxFieldSize(int max) throws SQLException {        stmt_.setMaxFieldSize(max);    }    public int getMaxRows() throws SQLException {        return stmt_.getMaxRows();    }    public void setMaxRows(int max) throws SQLException {        stmt_.setMaxRows(max);    }    public void setEscapeProcessing(boolean enable) throws SQLException {        stmt_.setEscapeProcessing(enable);    }    public int getQueryTimeout() throws SQLException {        return stmt_.getQueryTimeout();    }    public void setQueryTimeout(int seconds) throws SQLException {        stmt_.setQueryTimeout(seconds);    }    public void cancel() throws SQLException {    	oProxy_.touch();        stmt_.cancel();    }    public SQLWarning getWarnings() throws SQLException {        return stmt_.getWarnings();    }    public void clearWarnings() throws SQLException {        stmt_.clearWarnings();    }    public void setCursorName(String name) throws SQLException {        stmt_.setCursorName(name);    }    public boolean execute(String sql) throws SQLException {    	    	try {        	sSQL_=sql;    		StartExecute();    		return stmt_.execute(sql);        } catch (SQLException sqlerr) {		    this.Error(sqlerr);		    throw sqlerr;    	} finally {    		EndExecute();    	}            }    public ResultSet getResultSet() throws SQLException {    	oProxy_.touch();        return stmt_.getResultSet();    }    public int getUpdateCount() throws SQLException {    	oProxy_.touch();        return stmt_.getUpdateCount();    }    public boolean getMoreResults() throws SQLException {    	oProxy_.touch();        return stmt_.getMoreResults();    }    public void setFetchDirection(int direction) throws SQLException {        stmt_.setFetchDirection(direction);    }    public int getFetchDirection() throws SQLException {        return stmt_.getFetchDirection();    }    public void setFetchSize(int rows) throws SQLException {        stmt_.setFetchSize(rows);    }    public int getFetchSize() throws SQLException {        return stmt_.getFetchSize();    }    public int getResultSetConcurrency() throws SQLException {        return stmt_.getResultSetConcurrency();    }    public int getResultSetType() throws SQLException {        return stmt_.getResultSetType();    }    public void addBatch(String sql) throws SQLException {    	oProxy_.touch();    	sSQL_ = sql;        stmt_.addBatch(sql);    }    public void clearBatch() throws SQLException {    	oProxy_.touch();        stmt_.clearBatch();    }    /*     *      * @see addBatch     */    public int[] executeBatch() throws SQLException {    	try {    		this.StartExecute();    		return stmt_.executeBatch();        } catch (SQLException sqlerr) {		    this.Error(sqlerr);		    throw sqlerr;    	} finally {    		this.EndExecute();    	}    }    public Connection getConnection() throws SQLException {    	oProxy_.touch();        return stmt_.getConnection();    }    // below is not used for maybe it will have mich compatibility issue    public boolean getMoreResults(int current) throws SQLException {    	oProxy_.touch();    	return stmt_.getMoreResults(current);    }    public ResultSet getGeneratedKeys() throws SQLException {        return stmt_.getGeneratedKeys();    }    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {        return 0;    }    public int executeUpdate(String sql, int columnIndexes[]) throws SQLException {        return 0;    }    public int executeUpdate(String sql, String columnNames[]) throws SQLException {        return 0;    }    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {        return false;    }    public boolean execute(String sql, int columnIndexes[]) throws SQLException {        return false;    }    public boolean execute(String sql, String columnNames[]) throws SQLException {        return false;    }    public int getResultSetHoldability() throws SQLException {        return stmt_.getResultSetHoldability();    }    @Override    public boolean isClosed() throws SQLException {        return false;    }    @Override    public void setPoolable(boolean poolable) throws SQLException {    }    @Override    public boolean isPoolable() throws SQLException {        return false;    }    @Override    public void closeOnCompletion() throws SQLException {    }    @Override    public boolean isCloseOnCompletion() throws SQLException {        return true;    }    @Override    public <T> T unwrap(Class<T> iface) throws SQLException {        return null;    }    @Override    public boolean isWrapperFor(Class<?> iface) throws SQLException {        return false;    }    /**     * @since 1.4     public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {     return stmt_.executeUpdate(sql,columnIndexes);     }     public int getResultSetHoldability() throws SQLException {     return stmt_.getResultSetHoldability();     }     public int executeUpdate(String sql, String[] columnNames) throws SQLException {     return stmt_.executeUpdate(sql,columnNames);     }     public ResultSet getGeneratedKeys() throws SQLException {     return stmt_.getGeneratedKeys();     }     public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {     return stmt_.execute(sql,autoGeneratedKeys);     }     public boolean execute(String sql, String[] columnNames) throws SQLException {     return stmt_.execute(sql,columnNames);     }     public boolean execute(String sql, int[] columnIndexes) throws SQLException {     return stmt_.execute(sql,columnIndexes);     }     public boolean getMoreResults(int current) throws SQLException {     return stmt_.getMoreResults(current);     }     public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {     return stmt_.executeUpdate(sql,autoGeneratedKeys);     }     */}